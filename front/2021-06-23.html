<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>🔥 2022非面试季前端知识整理总结 | Herrylo`s Blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/image/logo.jpg">
    <link rel="shortcut icon" href="/image/logo.jpg">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/image/logotouchicon.jpg">
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <script>(function(c,l,a,r,i,t,y){
        c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
        t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
        y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
      })(window, document, "clarity", "script", "hqtyf5pdw0");</script>
    <meta name="description" content="面试季前端知识整理总结,Js基础,事件循环,异步方案,浏览器渲染原理,网络协议,前端框架,性能优化,设计模式">
    <meta charset="utf-8">
    <meta name="apple-mobile-web-app-title" content="Herrylo`s Blog">
    <meta name="application-name" content="Herrylo`s Blog">
    <meta name="twitter:title" content="Herrylo`s Blog">
    <meta name="og:site_name" content="Herrylo`s Blog">
    <meta name="og:url" content="https://herrylo.github.io/">
    <meta name="keywords" content="前端,JavaScript,ReactJs,前端开发,Nodejs,Docker,Rancher,数据结构,小程序,技术交流,技术分享">
    <meta property="og:title" content="Herrylo`s Blog">
    <meta property="og:description" content="This is my personal blog site, I hope to share the content can help you">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/image/logotouchicon.jpg">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/assets/css/0.styles.41c8c15c.css" as="style"><link rel="preload" href="/assets/js/app.91c9965d.js" as="script"><link rel="preload" href="/assets/js/3.44a65254.js" as="script"><link rel="preload" href="/assets/js/4.284460ba.js" as="script"><link rel="preload" href="/assets/js/52.e9d44c4c.js" as="script"><link rel="preload" href="/assets/js/9.c75c0a4a.js" as="script"><link rel="preload" href="/assets/js/8.a96c7ccd.js" as="script"><link rel="preload" href="/assets/js/10.86b6e0dd.js" as="script"><link rel="preload" href="/assets/js/7.d95a6a77.js" as="script"><link rel="preload" href="/assets/js/6.7678e14c.js" as="script"><link rel="preload" href="/assets/js/11.4cd9e10c.js" as="script"><link rel="preload" href="/assets/js/15.b7a9fb83.js" as="script"><link rel="preload" href="/assets/js/13.32463134.js" as="script"><link rel="prefetch" href="/assets/js/1.5a7329f1.js"><link rel="prefetch" href="/assets/js/12.a20f5378.js"><link rel="prefetch" href="/assets/js/14.9243954d.js"><link rel="prefetch" href="/assets/js/16.0f7e4e98.js"><link rel="prefetch" href="/assets/js/17.b9fb48fd.js"><link rel="prefetch" href="/assets/js/18.b57ef3b6.js"><link rel="prefetch" href="/assets/js/19.f52d83a1.js"><link rel="prefetch" href="/assets/js/20.e081c1b4.js"><link rel="prefetch" href="/assets/js/21.68d7deb4.js"><link rel="prefetch" href="/assets/js/22.3f8ec3b7.js"><link rel="prefetch" href="/assets/js/23.120fb17b.js"><link rel="prefetch" href="/assets/js/24.36343952.js"><link rel="prefetch" href="/assets/js/25.7810905b.js"><link rel="prefetch" href="/assets/js/26.05733481.js"><link rel="prefetch" href="/assets/js/27.d32dc1ba.js"><link rel="prefetch" href="/assets/js/28.9ba6205b.js"><link rel="prefetch" href="/assets/js/29.41468bb2.js"><link rel="prefetch" href="/assets/js/30.4fcd50bc.js"><link rel="prefetch" href="/assets/js/31.01b519c1.js"><link rel="prefetch" href="/assets/js/32.0605a918.js"><link rel="prefetch" href="/assets/js/33.07c4aa26.js"><link rel="prefetch" href="/assets/js/34.1289f798.js"><link rel="prefetch" href="/assets/js/35.35a61226.js"><link rel="prefetch" href="/assets/js/36.720e9176.js"><link rel="prefetch" href="/assets/js/37.4a31c7a1.js"><link rel="prefetch" href="/assets/js/38.5d2512dd.js"><link rel="prefetch" href="/assets/js/39.3e2ca350.js"><link rel="prefetch" href="/assets/js/40.2ca1976d.js"><link rel="prefetch" href="/assets/js/41.f7220ce9.js"><link rel="prefetch" href="/assets/js/42.63459eb7.js"><link rel="prefetch" href="/assets/js/43.ffc2c0f0.js"><link rel="prefetch" href="/assets/js/44.f28f58c4.js"><link rel="prefetch" href="/assets/js/45.bd91ee83.js"><link rel="prefetch" href="/assets/js/46.5d2b2be3.js"><link rel="prefetch" href="/assets/js/47.aec20681.js"><link rel="prefetch" href="/assets/js/48.5adc33b2.js"><link rel="prefetch" href="/assets/js/49.7b41cdec.js"><link rel="prefetch" href="/assets/js/5.56c5ebc3.js"><link rel="prefetch" href="/assets/js/50.ce734685.js"><link rel="prefetch" href="/assets/js/51.0f8f14d5.js"><link rel="prefetch" href="/assets/js/53.8e97fb29.js"><link rel="prefetch" href="/assets/js/54.d9b36632.js"><link rel="prefetch" href="/assets/js/55.56410bdb.js"><link rel="prefetch" href="/assets/js/56.0a383f13.js"><link rel="prefetch" href="/assets/js/57.7b995206.js"><link rel="prefetch" href="/assets/js/58.f53e4c54.js"><link rel="prefetch" href="/assets/js/59.1cf9b584.js"><link rel="prefetch" href="/assets/js/60.3665060c.js"><link rel="prefetch" href="/assets/js/61.13600541.js"><link rel="prefetch" href="/assets/js/62.f5e6d6c1.js"><link rel="prefetch" href="/assets/js/63.dc2f5a41.js"><link rel="prefetch" href="/assets/js/64.13f22f87.js"><link rel="prefetch" href="/assets/js/65.651ead61.js"><link rel="prefetch" href="/assets/js/66.1a116b21.js"><link rel="prefetch" href="/assets/js/67.c226b0be.js"><link rel="prefetch" href="/assets/js/68.ce8f883f.js"><link rel="prefetch" href="/assets/js/69.f7ae76ec.js"><link rel="prefetch" href="/assets/js/70.01eb86a8.js"><link rel="prefetch" href="/assets/js/71.5eb24207.js"><link rel="prefetch" href="/assets/js/72.83c608da.js"><link rel="prefetch" href="/assets/js/73.e5553e80.js"><link rel="prefetch" href="/assets/js/74.f49b9e18.js"><link rel="prefetch" href="/assets/js/75.5d63de95.js"><link rel="prefetch" href="/assets/js/76.c88cb96f.js"><link rel="prefetch" href="/assets/js/77.32a9fadf.js"><link rel="prefetch" href="/assets/js/78.063ae3b2.js"><link rel="prefetch" href="/assets/js/79.3829d3bc.js"><link rel="prefetch" href="/assets/js/80.af15cf5a.js"><link rel="prefetch" href="/assets/js/81.4e8fc694.js"><link rel="prefetch" href="/assets/js/82.5c5e5088.js"><link rel="prefetch" href="/assets/js/83.b28ed874.js"><link rel="prefetch" href="/assets/js/84.3715c490.js"><link rel="prefetch" href="/assets/js/85.ed443780.js"><link rel="prefetch" href="/assets/js/86.56c6a8ba.js">
    <link rel="stylesheet" href="/assets/css/0.styles.41c8c15c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Herrylo`s Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/vuepress-plugin/" class="nav-link">vuepress-plugin-md-tags</a></div><div class="nav-item"><a href="/front/" class="nav-link router-link-active">😎技术</a></div><div class="nav-item"><a href="/essay/" class="nav-link">🙈随笔</a></div><div class="nav-item"><a href="/recommend/" class="nav-link">👏推荐</a></div><div class="nav-item"><a href="https://github.com/HerryLo/BlogPress" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div><div class="nav-item"><a href="/vuepress-plugin/" class="nav-link">vuepress-plugin-md-tags</a></div><div class="nav-item"><a href="/front/" class="nav-link router-link-active">😎技术</a></div><div class="nav-item"><a href="/essay/" class="nav-link">🙈随笔</a></div><div class="nav-item"><a href="/recommend/" class="nav-link">👏推荐</a></div><div class="nav-item"><a href="https://github.com/HerryLo/BlogPress" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/front/" class="sidebar-heading clickable router-link-active open"><span>技术博文</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/front/2023-09-11.html" class="sidebar-link">. 直播流IOS无法播放问题排查</a></li><li><a href="/front/2023-08-23.html" class="sidebar-link">. 关于Web GIS基础知识</a></li><li><a href="/front/2023-07-23.html" class="sidebar-link">. 如何使用Github Actions发布npm包</a></li><li><a href="/front/2021-06-23.html" aria-current="page" class="active sidebar-link">🔥 2022非面试季前端知识整理总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#js基础" class="sidebar-link">Js基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#javascript数据类型5-1" class="sidebar-link">javaScript数据类型5+1</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#this指向" class="sidebar-link">this指向</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#模块化" class="sidebar-link">模块化</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#并发和并行" class="sidebar-link">并发和并行</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#异步方案" class="sidebar-link">异步方案</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#事件循环" class="sidebar-link">事件循环</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#异步方案-2" class="sidebar-link">异步方案</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#浏览器渲染原理" class="sidebar-link">浏览器渲染原理</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#网络协议" class="sidebar-link">网络协议</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#http-https" class="sidebar-link">HTTP/HTTPS</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#前端框架" class="sidebar-link">前端框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#react框架" class="sidebar-link">React框架</a></li></ul></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#性能优化" class="sidebar-link">性能优化</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#设计模式" class="sidebar-link">设计模式</a></li><li class="sidebar-sub-header"><a href="/front/2021-06-23.html#结尾" class="sidebar-link">结尾</a></li></ul></li><li><a href="/front/2023-01-08.html" class="sidebar-link">🔥 知道前端工程部署有哪些方式嘛？</a></li><li><a href="/front/2019-12-11.html" class="sidebar-link">🔥 GitHub-GitHub Action一键部署</a></li><li><a href="/front/2022-10-27.html" class="sidebar-link">🔥 React底层运行简记</a></li><li><a href="/front/2019-09-12.html" class="sidebar-link">🔥 JavaScript-图解的this指向</a></li><li><a href="/front/2019-09-05.html" class="sidebar-link">🔥 JavaScript-图解原型链</a></li><li><a href="/front/2023-02-20.html" class="sidebar-link">🔥 JavaScript-图解作用域</a></li><li><a href="/front/2021-02-05.html" class="sidebar-link">🔥 JavaScript-图解Promise</a></li><li><a href="/front/2019-08-17.html" class="sidebar-link">🔥 TCP-的三次握手和四次挥手</a></li><li><a href="/front/2019-08-02.html" class="sidebar-link">🔥 TCP&amp;UDP-传输层的TCP和UDP协议</a></li><li><a href="/front/2020-10-21.html" class="sidebar-link">🔥 JavaScript-Axios源码解析拦截器</a></li><li><a href="/front/2019-12-20.html" class="sidebar-link">🔥 JavaScript-react-redux原理解析</a></li><li><a href="/front/2019-10-26.html" class="sidebar-link">🔥 JavaScript-redux原理解析</a></li><li><a href="/front/2019-09-22.html" class="sidebar-link">🔥 JavaScript-Promise原理解析</a></li><li><a href="/front/2020-06-04.html" class="sidebar-link">🔥 JavaScript-ES6中的Iterator迭代器</a></li><li><a href="/front/2019-04-01.html" class="sidebar-link">🔥 JavaScript-JS如何工作：垃圾回收</a></li><li><a href="/front/2018-12-27.html" class="sidebar-link">🔥 JavaScript-闭包的错误使用</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/front/" class="sidebar-heading clickable router-link-active"><span>GIS地图</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/front/" class="sidebar-heading clickable router-link-active"><span>Web开发</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="contentwapper"><div class="theme-default-content content__default"><h1 id="_2021非面试季前端知识整理总结"><a href="#_2021非面试季前端知识整理总结" class="header-anchor">#</a> 2021非面试季前端知识整理总结</h1> <p>这次对前端技术涉及到的点进行了一次有序的整理，这样记得更牢，也希望可以帮助到大家，下面是目录结构。(其中有很多内容被简化了，有兴趣可以查看每个目录下的参考文档，内容相对更加详情)</p> <ul><li><a href="#js%E5%9F%BA%E7%A1%80">Js基础</a></li> <li><a href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">事件循环</a></li> <li><a href="#%E5%BC%82%E6%AD%A5%E6%96%B9%E6%A1%88">异步方案</a></li> <li><a href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86">浏览器渲染原理</a></li> <li><a href="#%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">网络协议</a></li> <li><a href="#%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6">前端框架</a></li> <li><a href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">性能优化</a></li> <li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li> <li><a href="#%E7%BB%93%E5%B0%BE">结尾</a></li></ul> <h2 id="js基础"><a href="#js基础" class="header-anchor">#</a> Js基础</h2> <h3 id="javascript数据类型5-1"><a href="#javascript数据类型5-1" class="header-anchor">#</a> javaScript数据类型5+1</h3> <p>基本类型：<code>number</code>、<code>string</code>、<code>undefined</code>、<code>boolean</code>、<code>null</code>;</p> <p>引用类型：<code>Object</code>;</p> <p>目前基本类型还添加了两个新成员：<code>symbol</code>、<code>BigInt</code>;</p> <p>基本类型和引用类型区别：前者按值访问，因此为我们操作的就是存储在变量中的实际值；后者不能直接操作对象所在的内存空间，在操作对象时，实际操作的是该对象的引用。</p> <p>基本类型存储在<code>栈</code>中；引用类型的 ‘变量’名称 存储在<code>栈</code>中，同时存储指针，该指针指向<code>堆</code>中的真实的值；（<code>栈</code>、<code>堆</code>概念可以直接搜索  &quot;js中栈和堆的概念和区别&quot;）</p> <p>参考：<a href="https://www.bookstack.cn/read/es6-3rd/spilt.9.docs-number.md" target="_blank" rel="noopener noreferrer">阮一峰 ECMAScript 6 (ES6) 标准入门教程 第三版<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>参考书：<a href="https://book.douban.com/subject/35396470/" target="_blank" rel="noopener noreferrer">犀牛书<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="this指向"><a href="#this指向" class="header-anchor">#</a> this指向</h3> <p>箭头函数：this继承包裹箭头函数的第一个普通函数中的this；</p> <p>普通函数：new（this指向新对象）——bind/apply/call（this是强制指向的this）——this指向函数上下文对象——this指向window；</p> <p>参考文章：<a href="https://juejin.cn/post/6844903941021384711" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903941021384711<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>参考书：<a href="https://book.douban.com/subject/35175321/" target="_blank" rel="noopener noreferrer">红宝书<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <p>一个函数引用另外一个函数内部变量就会形成闭包，闭包在平时开发中非常的多见；理解作用域链创建和使用的细节对理解闭包非常重要；</p> <p>参考文章：<a href="https://juejin.cn/post/6844903747957719053" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903747957719053<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>参考书：<a href="https://book.douban.com/subject/35175321/" target="_blank" rel="noopener noreferrer">红宝书<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="原型"><a href="#原型" class="header-anchor">#</a> 原型</h3> <p>每个对象被创建开始，就与另一个对象关联，从另一个对象上继承其属性，这里的另一个对象就是原型；</p> <p>原型存在的意义就是组成原型链。当范文一个对象属性时，先从对象本身找，找不到就去对象原型上找，如果还找不到，就去对象原型的原型上找，如此类推，直到找到为止；这条由对象及原型组成的查找链条就是原型链；</p> <p>参考文章：<a href="https://juejin.cn/post/6844903936365690894" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844903936365690894<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>参考书：<a href="https://book.douban.com/subject/35175321/" target="_blank" rel="noopener noreferrer">红宝书<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h3> <p>组合继承：通过 <code>call</code>修改子类<code>this</code>，将子类原型指向 <code>new 父类()</code>;</p> <p>寄生组合继承：通过  <code>call</code> 修改子类<code>this</code>，将子类原型指向父类原型（Object.create(父类.prototype)） ,并将子类原型构造函数指向子类；</p> <p>参考书：<a href="https://book.douban.com/subject/35175321/" target="_blank" rel="noopener noreferrer">红宝书<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="模块化"><a href="#模块化" class="header-anchor">#</a> 模块化</h3> <p>模块化特点：复用性、可维护性；</p> <p><code>commonJs</code>最早作为标准在NodeJs中引入， 作为NodeJs模块化标准；在<code>commonJs</code>中，<code>require</code>首次加载就会执行整个脚本，在内存中生成一个对象缓存下来，下次加载时可直接从缓存获取；
对于循环加载，只输出已执行的部分。还未执行部分不输出；</p> <p>最新ES6的 ES Module，是静态加载；脚本被加载时，成为一个指向被加载模块的引用，不会缓存；</p> <h3 id="并发和并行"><a href="#并发和并行" class="header-anchor">#</a> 并发和并行</h3> <p>区别：并发是两个或多个事件在同一时间间隔内发生；并行是指两个或多个事件在同一时刻内发生；</p> <p>并行通过提升硬件能力，只需要多核CPU即可达到；</p> <p>并发中最常听到的就是高并发，在一定时间，服务器的吞吐量和QPS每秒响应请求数都是一定的。而在这样的情况下，要解决高并发的问题，最简单当然是提升机器性能，加内存，加硬盘，升级网速。当然，通过架构层面设计，也可以做点东西，部署多台机器，添加负载均衡层，将请求均匀；将数据库分库分表并读写分离；引入消息中间件等；缓存集群引入；</p> <h3 id="异步方案"><a href="#异步方案" class="header-anchor">#</a> 异步方案</h3> <p>回调函数：在浏览器端，异步问题就是Ajax网络请求响应异步，而回调函数可以一定程度解决这个响应异步的问题，缺点是：不易维护、不易读、不能直接return；</p> <p><strong>Generator</strong>：封装多个内部状态的异步解决方案，生成器函数；会返回一个迭代器，配合next()函数，可以控制开始、暂停和恢复代码；
场景：控制流管理、异步操作；</p> <p><strong>Promise</strong>：解决异步操作方案，包含异步操作结果的对象；内部存在三种状态，一旦开始不可更改状态；问题：无法取消，错误需要回调捕获；Promise是链式调用，每次调用then之后返回一个Promise，并且是一个全新的Promise；</p> <p>Promise实现依据Promise/A+规范——</p> <p>三种状态：pedding、fulfilled、rejected；</p> <p>（Promise封装的Ajax为例子）进行异步处理流：执行Promise回调函数，由于异步操作，内部状态未变化。继续执行then回调，内部状态未变化，回调队列中then回调暂时不执行。此时，异步执行完成（网络请求响应），状态变化，Promise内部调用resolve函数，回调队列执行；</p> <p><strong>async/await</strong>：异步解决方案，需要配套使用；函数添加async后，函数会返回一个Promise；await内部实现了<strong>Generator，await是异步操作，后来的表达式不返回Promise的话，就会包装成Promise.resolve(返回值 )，然后去执行函数外的同步代码；</strong></p> <h2 id="事件循环"><a href="#事件循环" class="header-anchor">#</a> 事件循环</h2> <blockquote><p>一个事件循环又一个货多个任务队列；一个任务队列是一组任务；</p></blockquote> <div class="language- extra-class"><pre><code>1. 每个事件循环是一个正在运行的任务，它可以是一个任务或null；

2. 每个事件循环具有microtask队列（微任务队列），最初为空；

3. 每个事件循环都有一个执行微任务检查点的布尔值，该布尔值最初为false；
</code></pre></div><h4 id="_1-js的事件循环如何环执行"><a href="#_1-js的事件循环如何环执行" class="header-anchor">#</a> 1. js的事件循环如何环执行？</h4> <p>浏览器事件循环执行顺序：</p> <blockquote><ol><li>首先执行script脚本同步代码，属于宏任务；</li> <li>当执行完当前所有同步任务后，执行栈为空，查询是否有异步任务代码需要执行；</li> <li>执行当前宏任务下的所有微任务；</li> <li>微任务执行完之后，如有必要会渲染页面；</li> <li>然后开始下一轮事件循环；</li></ol></blockquote> <hr> <h4 id="_2-宏任务和微任务有哪些"><a href="#_2-宏任务和微任务有哪些" class="header-anchor">#</a> 2. 宏任务和微任务有哪些？</h4> <p>宏任务：script、setTimeout、setInterval、setImmediate、I/O、UI Render；</p> <p>微任务：process.nextTick、promise、MutationObsever；</p> <hr> <h4 id="_3-nodejs的事件循环和浏览器事件循环区别"><a href="#_3-nodejs的事件循环和浏览器事件循环区别" class="header-anchor">#</a> 3. Nodejs的事件循环和浏览器事件循环区别？</h4> <p>Nodejs和浏览器端，宏任务和微任务交替执行，调用顺序基本相同。Nodejs执行会进行阶段区分，分为6个阶段：<a href="https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener noreferrer">参考：Node.js 事件循环文档<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，每进入某个阶段，会从回调队列中取出函数执行。当队列为空或回调函数达到系统设定阈值，就进入下一个阶段。</p> <hr> <h2 id="异步方案-2"><a href="#异步方案-2" class="header-anchor">#</a> 异步方案</h2> <p>可以把ajax异步回调作为浏览器端的最初的异步解决方案，<code>异步回调 ———&gt; Promise实例 ——&gt; Generator ——&gt; async/await</code>，大致是一个这样的线，我们需要关注的可能主要就是Promise 和 async/await的方案。</p> <h4 id="_1-promise内部实现了解嘛-它的具体工作流程是怎么样的"><a href="#_1-promise内部实现了解嘛-它的具体工作流程是怎么样的" class="header-anchor">#</a> 1. Promise内部实现了解嘛？它的具体工作流程是怎么样的？</h4> <p>Promise是异步解决方案，包含异步操作结果的对象，特点：<code>内部存在三种状态，状态一旦变化不可更改状态；Promise是链式调用，每次调用then回调函数都会返回一个新的Promise，并且是一个全新的Promise；</code></p> <p>Promise异步处理流：<code>执行Promise实例回调函数，由于异步请求或者操作，此时状态未变化。继续执行then回调，由于状态未变化回调会被放入回调数组中。直到Promise实例中异步请求或者操作完成，状态发生变化，调用resolve函数，回调数组遍历执行，then回调函数拿到相关数据</code>。</p> <hr> <h4 id="_2-说一说async-await"><a href="#_2-说一说async-await" class="header-anchor">#</a> 2. 说一说async/await</h4> <p>参考：</p> <p><a href="https://juejin.cn/post/6844903954514444295" target="_blank" rel="noopener noreferrer">Promise原理解析<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6930859627961647117" target="_blank" rel="noopener noreferrer">图解Promise流程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="浏览器渲染原理"><a href="#浏览器渲染原理" class="header-anchor">#</a> 浏览器渲染原理</h2> <p>浏览器是多进程应用，每打开一个Tab页，就相当于创建了一个独立的浏览器进程。浏览器进程有：Browser进程(主进程)、插件进程、GPU进程、渲染进程(浏览器内核)。主进程只有一个是负责协调应用，同时默认每个Tab页面一个渲染进程，互不影响。我们常说的Js线程、GUI渲染线程就包含在渲染进程之中，还包括异步http请求线程、事件触发线程等。</p> <h4 id="_1-地址栏输入域名地址之后发生了什么"><a href="#_1-地址栏输入域名地址之后发生了什么" class="header-anchor">#</a> 1. 地址栏输入域名地址之后发生了什么？</h4> <div class="language- extra-class"><pre><code>1. DNS服务查询域名对应的目标服务IP地址；
2. 根据目标IP地址查找到目标服务器，并建立TCP连接；
3. 服务器响应返回数据或文本信息等；
4. 客户端获取到数据之后进行页面渲染；
</code></pre></div><h4 id="_2-浏览器渲染的流程"><a href="#_2-浏览器渲染的流程" class="header-anchor">#</a> 2. 浏览器渲染的流程？</h4> <div class="language- extra-class"><pre><code>1. 请求html文件处理html标记构建DOM树；
2. 请求css文件处理css标记构建CSSOM树；
3. 将DOM和CSSOM合并成一个渲染树；
4. 根据渲染树布局，以计算每个节点的几何信息；
5. 将各节点绘制在屏幕上；
</code></pre></div><p>存在阻塞的css资源时，浏览器会延迟JS的执行和DOM的构建；</p> <h4 id="_3-重绘和回流"><a href="#_3-重绘和回流" class="header-anchor">#</a> 3. 重绘和回流？</h4> <p><code>重绘</code>是当节点需要更改外观而不影响布局；<code>回流</code>是布局或几何属性需要改变；</p> <p><a href="https://developers.google.cn/web/fundamentals/performance/rendering" target="_blank" rel="noopener noreferrer">参考：渲染性能<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>参考：</p> <p><a href="https://juejin.cn/post/6844903553795014663" target="_blank" rel="noopener noreferrer">从浏览器多进程到JS单线程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://juejin.cn/post/6844903815758479374" target="_blank" rel="noopener noreferrer">你不知道的浏览器页面渲染机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="网络协议"><a href="#网络协议" class="header-anchor">#</a> 网络协议</h2> <p><img src="/Img/tcp_ip.png" alt=""></p> <p>关于TCP和UDP的介绍、TCP的三次握手和四次挥手就不细说，相关文章可以参考：<a href="https://juejin.cn/post/6844903905306886151" target="_blank" rel="noopener noreferrer"><strong>传输层协议TCP和UDP</strong> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="https://juejin.cn/post/6844903918334377991" target="_blank" rel="noopener noreferrer"><strong>TCP三次握手和四次挥手</strong> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>；</p> <p>http协议是常用的网络传输协议，全称是超文本传输协议，它规定了http请求和响应的具体结构，当然还包含其他东西，例如：缓存、文件类型、参数、请求类型、状态等。它是建立在传输层TCP协议之上的，TCP握手成功之后，才可以进行网络数据传输。</p> <h3 id="http-https"><a href="#http-https" class="header-anchor">#</a> HTTP/HTTPS</h3> <h4 id="_1-什么是http协议-它是怎么样的"><a href="#_1-什么是http协议-它是怎么样的" class="header-anchor">#</a> 1. 什么是http协议？它是怎么样的？</h4> <p>http是TCP/IP协议应用层协议，主要负责数据或文本图片等内容的传输，它是建立在传输层TCP协议之上的。http分为请求报文和响应报文，<code>从Web客户端发往Web服务器的HTTP报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文</code>，报文分为：起始行、 首部字段、主体等；</p> <hr> <h4 id="_2-http和https的区别"><a href="#_2-http和https的区别" class="header-anchor">#</a> 2. http和https的区别？</h4> <p>http和https从字面的区别就是一个s，这个s就是SSL/TCL加密协议。说到加密协议就绕不开加密技术，在SSL/TCL加密协议中既有用到非对称加密，也有用到对称加密。SSL/TCL加密协议相当于是在应用层和传输层之间加了一层，可称为加密层。</p> <p>大致流程：客户端向服务器端索要加密证书获取公钥等证书信息；双方协商生成&quot;对话密钥&quot;；双方采用&quot;对话密钥&quot;进行加密通信。非对称加密保证&quot;对话密钥&quot;的安全传输，对称加密保证客户端和服务端对数据的加解密。</p> <hr> <h4 id="_3-http网络缓存如何配置"><a href="#_3-http网络缓存如何配置" class="header-anchor">#</a> 3. http网络缓存如何配置？</h4> <p>如果需要开启强缓存和协商缓存，可在服务端nginx web服务器进行对应的配置，开启对应的网络缓存。其他服务端web服务器也可配置。(配置细节网上一大堆)</p> <hr> <h4 id="_4-强缓存和协商缓存的区别"><a href="#_4-强缓存和协商缓存的区别" class="header-anchor">#</a> 4. 强缓存和协商缓存的区别？</h4> <p><strong>强缓存</strong>：Cache-Control，常用属性有max-age、no-cache、no-store等。max-age表示相对时间内的缓存，在这个相对时间内不会再去请求对应资源；no-cache表示不意味着不缓存，它的意思是在使用缓存资源之前，它必须经过服务器的检查；
no-store表示不缓存。</p> <p><strong>协商缓存</strong>：Last-modified 和 ETag，这两个类似，可以理解为文件标识。也可以将ETag（你选择的版本ID）或者Last-modified日期添加到响应首部中。客户端下次获取资源时，他会分别通过If-None-Match（与ETage对应）和If-Modified-Since（与Last-Mofied对应）两个请求首部将值发送给服务器。如果服务器发现两次值都是对等的，就是返回一个HTTP 304。它们之间的区别：ETag 只要资源变化，它就会改变；Last-modified 不识别秒单位里的修改。</p> <p>如何使用—————前端中保证HTML资源是最新的，设置如：max-age=300、ETag、Last-modified，当然也可考虑使用no-cache、ETag、Last-modified配合。而CSS和JS找资源已经被注入到HTML中，资源文件地址通常使用哈希值加入文件名中保证资源是最新，css和js文件可设置：max-age=31536000或last-modified 配合使用。</p> <hr> <h4 id="_5-了解http2-0嘛-为什么说http2-0更好"><a href="#_5-了解http2-0嘛-为什么说http2-0更好" class="header-anchor">#</a> 5. 了解http2.0嘛？为什么说http2.0更好？</h4> <p>http2.0基于二进制分帧层，http2.0可以在共享TCP连接的基础上同时发送请求和响应。在http1.x中，是通过文本的方式传输数据，基于文本的方式传输数据存在很多缺陷，文本的表现形式有多样性，因此要做到健壮性考虑的场景必然有很多，但是二进制则不同，只有0和1的组合，因此选择了二进制传输，实现方便且健壮。</p> <p>为了保证http不受影响，那就需要在应用层（HTTP2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层。在二进制分帧层上，http2.0会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码，其中http1.x的首部信息会被封装到Headers帧，而Request Body则封装到Data帧。在传输中会共用一个TCP流（TCP连接中的一个虚拟通道，可以承载双向的消息），不至于重复连接。</p> <hr> <p>参考：</p> <p><a href="https://book.douban.com/subject/10746113/" target="_blank" rel="noopener noreferrer">书籍：HTTP权威指南<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener noreferrer">SSL/TLS协议运行机制的概述<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="前端框架"><a href="#前端框架" class="header-anchor">#</a> 前端框架</h2> <p>前端框架目前市面主流就是React和Vue，对于框架的使用和学习，前期建议多翻翻文档，中期根据自己在使用过程中遇到的问题学习，后期就可以考虑翻源码了。由于工作原因，我对react了解更多，所以分享主要就是React。</p> <p>React和Vue作为前端框架在本质上做的是相同的事，在浏览器和开发操作之间加了一个中间层，来进项目的辅助管理和开发。</p> <h3 id="react框架"><a href="#react框架" class="header-anchor">#</a> React框架</h3> <h4 id="_1-jsx本质是什么-它和js的关系是什么-为什么使用jsx"><a href="#_1-jsx本质是什么-它和js的关系是什么-为什么使用jsx" class="header-anchor">#</a> 1. JSX本质是什么，它和JS的关系是什么？为什么使用JSX？</h4> <p><code>JSX</code>是类HTML的语法结构，实质是<code>JS</code>的语法扩张。它语法结构简洁，通俗易懂，对于研发效率和体验有大的提升。</p> <hr> <h4 id="_2-jsx背后的功能模块是什么-这个功能模块做了哪些事情"><a href="#_2-jsx背后的功能模块是什么-这个功能模块做了哪些事情" class="header-anchor">#</a> 2. JSX背后的功能模块是什么，这个功能模块做了哪些事情？</h4> <p><code>JSX</code>通过<code>babel</code>语法转换之后，实际就是通过<code>React.createElement</code>函数来创建React元素。<code>createElement</code>接收三个参数<code>type</code>类型，<code>config</code>配置，<code>children</code>子元素。通过<code>createElement</code>就可创建出虚拟<code>DOM</code>对象。</p> <hr> <h4 id="_3-react16-3新旧生命周期-消失的旧生命周期有哪些"><a href="#_3-react16-3新旧生命周期-消失的旧生命周期有哪些" class="header-anchor">#</a> 3. react16.3新旧生命周期，消失的旧生命周期有哪些？</h4> <p>去掉<code>ComponentWillMount</code>和<code>CompoentWillReceiveProps</code>
升级为<code>getDeicvedStateFromProps</code>，保证生命周期更加单一，更可控；去掉ComponentWillUpdate新增getSnapshotDeforeUpdate；</p> <hr> <h4 id="_4-react团队为什么要去掉旧的生命周期函数"><a href="#_4-react团队为什么要去掉旧的生命周期函数" class="header-anchor">#</a> 4. React团队为什么要去掉旧的生命周期函数？</h4> <p>React16+引入<code>Fiber</code>架构，<code>Fiber</code>会将一个大的更新任务拆解为多个小任务，而且它是可中止，可恢复的。React16+生命周期被划分为<code>render</code>和<code>commit</code>两个阶段。<code>render</code>阶段在执行过程中允许被打断，而commit阶段操作涉及真实DOM渲染，是不可打断的。</p> <p><code>ComponentWillMount</code>、
<code>ComponentWillUpdate</code>、
<code>ComponentWillReceiveProps</code>
这些生命周期，它们都处于<code>render</code>阶段，而在<code>Fiber</code>架构中，<code>render</code>阶段会被打断，重复被执行。在这些生命周期可能习惯做的事情可能有：setState、异步请求、操作真实DOM等。而在Fiber异步渲染控制下，这些生命周期可能会导致非常严重的bug（例如在这些废弃的生命周期中调用支付接口）。</p> <hr> <h4 id="_5-react组件数据如何流动-实现数据通信的方案有哪些"><a href="#_5-react组件数据如何流动-实现数据通信的方案有哪些" class="header-anchor">#</a> 5. React组件数据如何流动？实现数据通信的方案有哪些？</h4> <p>react是自上而下的单向组件数据流</p> <div class="language- extra-class"><pre><code>1.父-子组件通过prop属性传递数据，子-父组件可通过函数；
2.兄弟组件共享同一个父组件，达到兄弟组件通信；
3.Context API实现全局通信；（目前还没试过）
4.redux数据状态容，进行可预测的状态管理；
5.发布/订阅模式实现任意组件通信；
</code></pre></div><hr> <h4 id="_6-为什么是react-hooks"><a href="#_6-为什么是react-hooks" class="header-anchor">#</a> 6. 为什么是React Hooks？</h4> <p>相对于<code>Class</code>组件，函数组件更加轻量，更加符合UI=render(data)特点。同时在Fiber架构的加持下，Hooks的实现不是问题。配合函数组件的发展，Hooks应运而生，从而是函数组件真正把数据和渲染绑定到一起。当然Hooks也还是存在部分不足：部分周期不存在；不能很好的消化“复杂”，组件的拆分和组织是一个大的挑战，不易把握。</p> <hr> <h4 id="_7-为什么hooks执行顺序如此重要"><a href="#_7-为什么hooks执行顺序如此重要" class="header-anchor">#</a> 7. 为什么Hooks执行顺序如此重要？</h4> <p>Hooks本质是链表。例如 使用useText、useState创建state时，hook创建的state会以单链表形式保存，更新时，函数组件重新调用，hooks会依次遍历单链表，读取数据并更新，这一过程完全按照创建时的顺序来的。因此当更新时，位置一旦改变，执行顺序被替换，运行就会出现bug。</p> <hr> <h4 id="_8-调和-协调-和diff的关系或区别"><a href="#_8-调和-协调-和diff的关系或区别" class="header-anchor">#</a> 8. 调和(协调)和diff的关系或区别？</h4> <p>调和指的是虚拟DOM映射到真实DOM的过程。调和过程并不能喝diff画等号。调和是“使一致”的过程，而diff是“找不同”的过程，它只是“使一致”过程中的一个环节。(当然常说的调和相关问题多半就是diff过程的)</p> <hr> <h4 id="_9-react的diff逻辑和思路"><a href="#_9-react的diff逻辑和思路" class="header-anchor">#</a> 9. react的diff逻辑和思路？</h4> <div class="language- extra-class"><pre><code>1.因为时间复杂度的原因，diff过程只针对同层的节点作比较；
2.对于同类型的组件，才有进一步对比的必要性；
3.对于列表组件，通过key属性来维持节点的稳定性，避免总是生产新节点；
</code></pre></div><hr> <h4 id="_10-setstate的工作流是怎么样的"><a href="#_10-setstate的工作流是怎么样的" class="header-anchor">#</a> 10. setState的工作流是怎么样的？</h4> <p>非并发(<code>concurrent</code>)模式：<code>setState</code>会出现异步和同步的现象。在生命周期和合成事件中是同步，而在setTimeout、setInterval、DOM原生函数等函数中是同步的。那么这是为什么尼？在合成事件或生命周期执行时，批量更新的任务锁就被开启了，我们所做的setState操作会被放入到批量更新队列中，直到函数执行完，批量更新的任务锁才会被关闭。批量更新的任务锁是一个同步操作，而一旦你在setTimeout函数使用setState，此时setTimeout函数回调会被放入下一个宏任务执行，而当setState执行时，批量更新的任务锁时关闭的，它就不会放入到批量更新队列中，而是直接执行。</p> <p>并发(<code>concurrent</code>)模式：<code>setState</code>不会出现异步和同步的现象。因为存在时间切片，只要当前时间片没有结束，依旧可以将多个 setState 合并成一个，即使是在setTimeout中被调用。而对于超过当前时间片的操作，会通过<code>MessageChannel</code>放入到下一个宏任务中继续执行。（<code>MessageChannel</code>接收消息的时机比 Promise 所在的 microTask 要晚，但是早于 setTimeout）</p> <hr> <h4 id="_11-stack-reconciler栈调和-有怎么样的局限性"><a href="#_11-stack-reconciler栈调和-有怎么样的局限性" class="header-anchor">#</a> 11. Stack Reconciler栈调和 有怎么样的局限性？</h4> <p>浏览器中Js线程和渲染线程是互斥的。这两个线程不能穿插执行，必须串行。而当Js线程长时间占用主线程，那么渲染线程的更新就不得不长时间的等待，这时就会导致页面卡顿。</p> <p><code>Stack Reconciler</code>栈调和是一个同步递归过程，虚拟DOM树diff算法遍历是深度优先遍历。由于它是同步的，不可在被打断。当处理结构复杂，体量庞大的虚拟DOM树时，<code>Stack Reconciler</code>时间会很长，以为这Js主线程长时间占用主线程，进而导致上述中说道的渲染卡顿/页面卡死。</p> <hr> <h4 id="_12-说一说fiber架构"><a href="#_12-说一说fiber架构" class="header-anchor">#</a> 12. 说一说Fiber架构？</h4> <p>特点：可中断、可恢复、存在优先级。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code> Scheduler ————&gt; Reconciler ————&gt; Renderer
 更新优先级         找不同         渲染不同
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在<code>Fiber</code>架构模式下，每个更新任务会被赋予一个优先级。当然有任务A进入调度器，这个任务优先级更高，而<code>Reconciler</code>中已有任务B在执行，那么，<code>Reconciler</code>会将任务B终止，更高优先级的任务A被推入<code>Reconciler</code>。当A任务完成之后，新一轮调度会将之前中断的任务B重新推入<code>Reconciler</code>，继续它的渲染之旅。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>render开始 ——————&gt; (工作单元| 工作单元 | 工作单元) ——————&gt; commit提交渲染
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h4 id="_13-reactdom-render调用栈的初始化阶段、render阶段"><a href="#_13-reactdom-render调用栈的初始化阶段、render阶段" class="header-anchor">#</a> 13. ReactDOM.render调用栈的初始化阶段、render阶段</h4> <p>初始化阶段：会创建root对象这个对象挂载<code>_internalRoot</code>属性，而<code>_internalRoot</code>也就是<code>FiberRoot</code>。<code>FiberRoot</code>的本质是一个<code>FiberRootNode</code>对象，其中包含current属性，current对象是一个FiberNode实例。current对象就是一个Fiber节点，并是Fiber树的头部节点；确定Fiber的优先级，结合优先级创建当前Fiber的update对象，并将其入队调度FiberRoot；接下来进入render阶段；(此时相当于只有一个Fiber头部节点)</p> <p>render阶段：通过createWorkInProgress函数，创建rootFiber节点的副本workInProgress节点树(即current节点的副本节点)，他们通过alternate互相引用；接着会触发beginWork函数，进而实现对新的Fiber节点的创建。循环遍历，组件元素Fiber会不断被创建(每个元素节点对应一个Fiber节点)，直到创建到最后一个为止，此时Fiber树(单链表)基本完成；<strong>重点</strong>：此时已经遍历到了单链表的最底部节点，然后会<strong>由下自上</strong>的依次生成真实DOM节点，同时被它的父组件副作用链，这个副作用链也是一个单链表，直遍历到根节点，此时的根节点上的副作用链就包含的全部的DOM更新。那么剩下的只需要拿到root下的副作用链更新即可了。</p> <hr> <p>参考：</p> <p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=510#/content" target="_blank" rel="noopener noreferrer">修言 深入浅出搞定 React<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://segmentfault.com/a/1190000024560483" target="_blank" rel="noopener noreferrer">React 架构的演变 - 从同步到异步<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://segmentfault.com/a/1190000025177720" target="_blank" rel="noopener noreferrer">React 架构的演变 - 从递归到循环<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://segmentfault.com/a/1190000037447202" target="_blank" rel="noopener noreferrer">React 架构的演变 - 更新机制<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://segmentfault.com/a/1190000037618578" target="_blank" rel="noopener noreferrer">React 架构的演变 - Hooks 的实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="性能优化"><a href="#性能优化" class="header-anchor">#</a> 性能优化</h2> <p>可使用Chrome Lighthouse进行性能测评，根据测评结果也可以得出一些改进的点：</p> <p>react框架层面可以做的优化方向核心点：<strong>减少重新 render 的次数</strong>；<strong>减少计算的量，主要是减少重复计算</strong>。有下列具体方案：</p> <div class="language- extra-class"><pre><code>1. 拆分公共组件和业务组件，根据具体业务分离，降低组件颗粒度；
2. shouldComponentUpdate中拦截非不要渲染；
3. 对于简单的数据类型，可考虑使用React.PureComponent；
4. 函数组件考虑使用React.meno，React.memo 与 React.PureComponent 非常相似；(版本React 16.6.0)
5. React Hooks组件使用useCallback缓存函数，避免每次返回一个新的函数；(版本React v16.8)
6. React Hooks组件使用useMemo缓存计算值；(版本React v16.8)
</code></pre></div><p>一个前端项目下通用的优化技巧：使用缓存、节流、压缩、按需加载、全局管理等方法或技巧。如下：</p> <div class="language- extra-class"><pre><code>1. 避免频繁渲染更新，即使必须的情况下，也需要考虑是否使用节流函数；
2. 对于长列表页面，考虑翻页加载、点击下一页或者虚拟长列表，避免数据量过大，渲染卡顿；
3. 统一控制项目中的定时器函数，避免定时器偷跑；
4. 拆分Js文件，可考虑按需加载，提升加载速度；
5. 保证首屏必要数据渲染，可增加过渡图片，提升用户体验；
6. 对于后端接口多余数据可考虑清洗数据，只保留必要数据；
7. 避免过多的数据请求，可考虑使用数据缓存，提升用户体验；
8. 对于大图考虑CDN图片加载，也可考虑图片懒加载；
9. 避免使用过多css选择器嵌套；
10. 代码文件gzip压缩等，服务器相关缓存配置；
</code></pre></div><p><strong>以上更多的是各种技巧和原则，如果要知道具体的标准，可以参考google为Web性能表现提供的文档</strong><a href="https://developers.google.cn/web/fundamentals/performance/get-started" target="_blank" rel="noopener noreferrer"><strong>developers.google.cn/Web Performance</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="设计模式"><a href="#设计模式" class="header-anchor">#</a> 设计模式</h2> <p>参考文章：<a href="https://www.yuque.com/yopai/pp6bv5" target="_blank" rel="noopener noreferrer">https://www.yuque.com/yopai/pp6bv5<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="结尾"><a href="#结尾" class="header-anchor">#</a> 结尾</h2> <p>以上内容是以<a href="https://juejin.cn/book/6844733763675488269" target="_blank" rel="noopener noreferrer">前端面试之道<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>目录结构作为大纲进行的系统的整理，有修改也有添加，其中的内容大部分都是查看博客和相关资料获取的，因为自己也有薄弱的地方，所以有些目录下的内容偏少。如果有有更多补偿可以评论或者单独发我，谢谢✍✍。</p></div> <div class="right-wrapper"><div class="right-time"><div class="content-title">🥰Me</div> <div class="content-wrapper"><p>男性，武汉工作，会点Web，擅长Javascript.</p> <p>技术或工作问题交流，可联系微信：<i>1169170165</i>.</p></div></div> <div class="right-obort"><div class="content-title">🚀关于</div> <div class="content-wrapper"><a href="https://github.com/HerryLo" target="_blank"><div data-id="zhihu" class="shield-item" style="border-color:rgb(24, 23, 23);"><img src="/image/github.svg" alt="GitHub"> <div class="col-7" style="color:rgb(24, 23, 23);">GitHub</div> <div id="shield-number-zhihu" class="col align-self-end shield-number" style="background-color:rgb(24, 23, 23);">🚀🚀🚀🚀</div></div></a><a href="https://juejin.cn/user/430664289365608" target="_blank"><div data-id="zhihu" class="shield-item" style="border-color: #1e80ff;"><img src="/image/juejin.svg" alt="掘金"> <div class="col-7" style="color: #1e80ff;">掘金</div> <div id="shield-number-zhihu" class="col align-self-end shield-number" style="background-color: #1e80ff;">🚀🚀🚀😄</div></div></a><a href="https://www.yuque.com/yopai" target="_blank"><div data-id="zhihu" class="shield-item" style="border-color:#2ac15b;"><img src="/image/yuque.svg" alt=" 语雀"> <div class="col-7" style="color:#2ac15b;"> 语雀</div> <div id="shield-number-zhihu" class="col align-self-end shield-number" style="background-color:#2ac15b;">🚀🚀😄😄</div></div></a><a href="https://www.zhihu.com/people/liu-heng-88-71" target="_blank"><div data-id="zhihu" class="shield-item" style="border-color:rgb(0, 117, 210);"><img src="/image/zhihu.svg" alt="知乎"> <div class="col-7" style="color:rgb(0, 117, 210);">知乎</div> <div id="shield-number-zhihu" class="col align-self-end shield-number" style="background-color:rgb(0, 117, 210);">🚀😄😄😄</div></div></a><a href="https://segmentfault.com/u/herrylo" target="_blank"><div data-id="zhihu" class="shield-item" style="border-color:#00965e;"><img src="/image/sf.svg" alt="segmentfault"> <div class="col-7" style="color:#00965e;">segmentfault</div> <div id="shield-number-zhihu" class="col align-self-end shield-number" style="background-color:#00965e;">😄😄😄😄 </div></div></a></div></div> <div class="right-group"><div class="content-title">🚀小程序&amp;公众号</div> <div class="content-wrapper"><div class="item"><img width="100%" src="https://herrylo.github.io/image/gh_blog.jpg"></div> <div class="item"><img width="75%" src="https://herrylo.github.io/image/qrcode_for_gh.jpg"></div></div></div> <div class="right-time"><div class="content-title">🚀运行</div> <div class="content-wrapper"><div class="currenttime">2024年2月19日星期一下午2点01分</div> <div class="timedesc">博客已运行：--天--时--分--秒</div></div></div> <div class="right-links"><div class="content-title">😁友链</div> <div class="content-wrapper"><div class="link-item"><div><a target="_blank" href="http://web-abin.gitee.io/blog/" class="link-name">Abin tools</a></div> <a target="_blank" href="https://web-abin.gitee.io/abin-web/tools" class="link">https://web-abin.gitee.io/abin-web/tools</a></div><div class="link-item"><div><a target="_blank" href="https://www.iceice.top/" class="link-name">Sky's blog</a></div> <a target="_blank" href="https://www.iceice.top/" class="link">https://www.iceice.top/</a></div><div class="link-item"><div><a target="_blank" href="https://www.xianchan.ah.cn" class="link-name">衔蝉 Blog</a></div> <a target="_blank" href="https://www.xianchan.ah.cn" class="link">https://www.xianchan.ah.cn</a></div><div class="link-item"><div><a target="_blank" href="https://blogweb.cn/" class="link-name">blogweb</a></div> <a target="_blank" href="https://blogweb.cn/" class="link">https://blogweb.cn/</a></div><div class="link-item"><div><a target="_blank" href="https://blog.krimeshu.com/" class="link-name">krimeshu</a></div> <a target="_blank" href="https://blog.krimeshu.com/" class="link">https://blog.krimeshu.com/</a></div><div class="link-item"><div><a target="_blank" href="https://www.tsix.top/" class="link-name">Tsix's 编程日记</a></div> <a target="_blank" href="https://www.tsix.top/" class="link">https://www.tsix.top/</a></div></div></div></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">7/18/2023, 6:00:41 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/front/2023-07-23.html" class="prev">
          . 如何使用Github Actions发布npm包
        </a></span> <span class="next"><a href="/front/2023-01-08.html">
          🔥 知道前端工程部署有哪些方式嘛？
        </a>
        →
      </span></p></div>  <div><section class="page-edit"><div><span data-flag-title="Your Article Title" class="leancloud-visitors"><em class="post-meta-item-text">阅读量： </em> <i class="leancloud-visitors-count"></i></span></div> <h3><a href="javascript:;"></a>
      评 论：
    </h3> <div id="vcomments"></div></section></div></main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.91c9965d.js" defer></script><script src="/assets/js/3.44a65254.js" defer></script><script src="/assets/js/4.284460ba.js" defer></script><script src="/assets/js/52.e9d44c4c.js" defer></script><script src="/assets/js/9.c75c0a4a.js" defer></script><script src="/assets/js/8.a96c7ccd.js" defer></script><script src="/assets/js/10.86b6e0dd.js" defer></script><script src="/assets/js/7.d95a6a77.js" defer></script><script src="/assets/js/6.7678e14c.js" defer></script><script src="/assets/js/11.4cd9e10c.js" defer></script><script src="/assets/js/15.b7a9fb83.js" defer></script><script src="/assets/js/13.32463134.js" defer></script>
  </body>
</html>
