(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{766:function(_,v,t){"use strict";t.r(v);var e=t(15),s=Object(e.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"浅读-深入浅出nodejs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅读-深入浅出nodejs"}},[_._v("#")]),_._v(" 浅读-深入浅出Nodejs")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/618012248",target:"_blank",rel:"noopener noreferrer"}},[_._v("原文链接"),t("OutboundLink")],1)]),_._v(" "),t("p",[_._v("原书作者：朴灵 https://book.douban.com/subject/25768396/")]),_._v(" "),t("p",[_._v("这次算是重读 深入浅出Nodejs，了解到很多之前忽略的细节，收获蛮多，这次顺便将其记录分享，对学习和了解Nodejs有及其大的帮助。")]),_._v(" "),t("h2",{attrs:{id:"_1-nodejs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-nodejs"}},[_._v("#")]),_._v(" 1.Nodejs")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("_事件驱动、_非阻塞IO，一个开源和跨平台的 JavaScript 运行时环境")]),_._v("；")]),_._v(" "),t("li",[_._v("异步I/O：每个调用之间无须等待之前的I/O调用结束；")]),_._v(" "),t("li",[_._v("事件：轻量级、松耦合、只关注事务点；")]),_._v(" "),t("li",[_._v("Node擅长I/O密集型的应用场景；（适合面向网络，不适合慢IO，如读磁盘）")])]),_._v(" "),t("h2",{attrs:{id:"_2-模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-模块"}},[_._v("#")]),_._v(" 2.模块")]),_._v(" "),t("ul",[t("li",[_._v("CommonJS的模块规范。Node中引入模块三步：路径分析、文件定位、编译执行；")]),_._v(" "),t("li",[_._v("不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查；")])]),_._v(" "),t("p",[t("img",{attrs:{src:"/image/9F250D83-1940-4518-B757-8405262F1F2F.png",alt:"9F250D83-1940-4518-B757-8405262F1F2F.png"}})]),_._v(" "),t("h2",{attrs:{id:"_3-异步io"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-异步io"}},[_._v("#")]),_._v(" 3.异步IO")]),_._v(" "),t("ul",[t("li",[_._v("单线程异步编程，极大的利用资源，避免单线程阻塞，更好的利用CPU；")]),_._v(" "),t("li",[_._v("完美的异步I/O应该是应用程序发起非阻塞调用，无须通过遍历或者事件唤醒等方式轮询，可以直接处理下一个任务，只需在I/O完成后通过信号或回调将数据传递给应用程序即可；")]),_._v(" "),t("li",[_._v("注意：Nodejs单线程仅仅只是JavaScript执行在单线程中。在Node中，无论是*nix还是Windows平台，内\t部完成I/O任务的另有线程池；")])]),_._v(" "),t("h3",{attrs:{id:"node异步i-o"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#node异步i-o"}},[_._v("#")]),_._v(" Node异步I/O")]),_._v(" "),t("ul",[t("li",[_._v("事件循环：Node便会创建一个类似于while(true)的循环，每执行一次循环体的过程我们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程；")]),_._v(" "),t("li",[_._v("观察者：在每个Tick的过程中，如何判断是否有事件需要处理呢？这里必须要引入的概念是观察者。每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程，就是向这些观察者询问是否有要处理的事件；")])]),_._v(" "),t("p",[_._v("事件循环是一个典型的"),t("strong",[_._v("生产者/消费者模型")]),_._v("。异步I/O、网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理；\n"),t("img",{attrs:{src:"/image/6EAE61B7-ED3B-4188-B801-EABD9B5EFC3D.png",alt:"6EAE61B7-ED3B-4188-B801-EABD9B5EFC3D.png"}})]),_._v(" "),t("h3",{attrs:{id:"非i-o异步api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非i-o异步api"}},[_._v("#")]),_._v(" 非I/O异步API")]),_._v(" "),t("p",[t("code",[_._v("setTimeout()")]),_._v("、"),t("code",[_._v("setInterval()")]),_._v("、"),t("code",[_._v("setImmediate()")]),_._v("和"),t("code",[_._v("process.nextTick()")]),_._v("；\n"),t("strong",[_._v("setTimeout")])]),_._v(" "),t("ul",[t("li",[t("code",[_._v("setTimeout()")]),_._v("和"),t("code",[_._v("setInterval()")]),_._v("与浏览器中的API是一致的，分别用于单次和多次定时执行任务。")]),_._v(" "),t("li",[_._v("调用"),t("code",[_._v("setTimeout()")]),_._v("或者"),t("code",[_._v("setInterval()")]),_._v("创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的回调函数将立即执行。")])]),_._v(" "),t("p",[t("img",{attrs:{src:"/image/E1F03D22-5113-4df2-8972-1F469F6E8242.png",alt:"E1F03D22-5113-4df2-8972-1F469F6E8242.png"}})]),_._v(" "),t("p",[t("strong",[_._v("process.nextTick")])]),_._v(" "),t("ul",[t("li",[_._v("每次调用"),t("code",[_._v("process.nextTick()")]),_._v("方法，只会将回调函数放入队列中，在下一轮Tick时取出执行；")])]),_._v(" "),t("p",[t("strong",[_._v("setImmediate")])]),_._v(" "),t("ul",[t("li",[t("code",[_._v("setImmediate()")]),_._v(" 参数传入的任何函数都是在事件循环的下一个迭代中执行的回调；")]),_._v(" "),t("li",[_._v("延迟 0 毫秒的 "),t("code",[_._v("setTimeout()")]),_._v(" 回调与 "),t("code",[_._v("setImmediate()")]),_._v(" 非常相似。 执行顺序取决于各种因素，但是它们都会在事件循环的下一个迭代中运行；")])]),_._v(" "),t("h3",{attrs:{id:"区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[_._v("#")]),_._v(" 区别")]),_._v(" "),t("ul",[t("li",[_._v("传给 "),t("code",[_._v("process.nextTick()")]),_._v(" 的函数会在事件循环的当前迭代中（当前操作结束之后）被执行。 这意味着它会始终在 "),t("code",[_._v("setTimeout")]),_._v(" 和 "),t("code",[_._v("setImmediate")]),_._v(" 之前执行。")]),_._v(" "),t("li",[t("strong",[_._v("同步和异步的区别")]),_._v("。也就是说，是否是同步还是异步，关注的是任务完成时消息通知的方式。由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用；")]),_._v(" "),t("li",[t("strong",[_._v("是否是阻塞还是非阻塞")]),_._v("，关注的是接口调用（发出请求）后等待数据返回时的状态。被挂起无法执行其他操作的则是阻塞型的，可以被立即「抽离」去完成其他「任务」的则是非阻塞型的；")])]),_._v(" "),t("p",[_._v("参考文章：")]),_._v(" "),t("h2",{attrs:{id:"_4-异步编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-异步编程"}},[_._v("#")]),_._v(" 4.异步编程")]),_._v(" "),t("ul",[t("li",[_._v("优点：利用事件循环的方式，JavaScript线程像一个分配任务和处理结果的大管家，I/O线程池里的各个I/O线程都是小二，负责兢兢业业地完成分配来的任务，小二与管家之间互不依赖，保持整体高效率；")]),_._v(" "),t("li",[_._v("缺点：这个模型的缺点则在于管家无法承担过多的细节性任务，如果承担太多，则会影响到任务的调度；（CPU密集型是弱点）")])]),_._v(" "),t("h3",{attrs:{id:"异步编程解决方案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步编程解决方案"}},[_._v("#")]),_._v(" 异步编程解决方案")]),_._v(" "),t("ul",[t("li",[_._v("事件发布/订阅模式；")]),_._v(" "),t("li",[_._v("Promise/Deferred模式；")]),_._v(" "),t("li",[_._v("流程控制库；")])]),_._v(" "),t("h3",{attrs:{id:"异步并发控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#异步并发控制"}},[_._v("#")]),_._v(" 异步并发控制")]),_._v(" "),t("ul",[t("li",[_._v("异步调用的并发限制在不同场景下的需求不同：非实时场景下，让超出限制的并发暂时等待执行可以满足需求；（一个队列来控制并发量，如果当前活跃（指调用发起但未执行回调）的异步调用量小于限定值，从队列中取出执行。如果活跃调用达到限定值，调用暂时存放在队列中。❑ 每个异步调用结束时，从队列中取出新的异步调用执行）")])]),_._v(" "),t("h2",{attrs:{id:"_5-内存控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-内存控制"}},[_._v("#")]),_._v(" 5.内存控制")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("V8堆内存的最大值在64位系统上为1464 MB, 32位系统上则为732 MB；")])]),_._v(" "),t("li",[_._v("在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象；")]),_._v(" "),t("li",[t("strong",[_._v("Node的内存构成主要由通过V8进行分配的部分和Node自行分配的部分，受V8的垃圾回收限制的主要是V8的堆内存")]),_._v("。（利用堆外内存可以突破内存限制的问题，如 "),t("strong",[_._v("Buffer")]),_._v("）")]),_._v(" "),t("li",[t("strong",[_._v("内存泄漏原因：缓存、队列消费不及时、作用域未释放；")])]),_._v(" "),t("li",[_._v("操作大文件可以使用stream模块用于处理；")])]),_._v(" "),t("h2",{attrs:{id:"_6-理解buffer"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-理解buffer"}},[_._v("#")]),_._v(" 6.理解Buffer")]),_._v(" "),t("ul",[t("li",[_._v("Buffer主要用于操作字节；")]),_._v(" "),t("li",[_._v("小而频繁的Buffer操作时，采用slab的机制进行预先申请和事后分配，使得JavaScript到操作系统之间不必有过多的内存申请方面的系统调用；")]),_._v(" "),t("li",[_._v("大块的Buffer对象，直接使用C++层面提供的内存；")])]),_._v(" "),t("h2",{attrs:{id:"_7-网络编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-网络编程"}},[_._v("#")]),_._v(" 7.网络编程")]),_._v(" "),t("p",[_._v("Nodejs提供的"),t("code",[_._v("net")]),_._v("、"),t("code",[_._v("dgram")]),_._v("、"),t("code",[_._v("http")]),_._v("、"),t("code",[_._v("tls")]),_._v("等模块，让面向网络编程更加便捷。\n通过"),t("code",[_._v("http")]),_._v("模块即可快速搭建Web服务器；网络是轻IO操作，再配合上Nodejs异步IO，Nodejs在面向网络编程方面能维持的并发量和QPS都是不容小觑的；")]),_._v(" "),t("h2",{attrs:{id:"_8-构建web应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-构建web应用"}},[_._v("#")]),_._v(" 8.构建Web应用")]),_._v(" "),t("p",[_._v("告诉开发者如何通过Nodejs构建一个合格的网络应用服务。")]),_._v(" "),t("ol",[t("li",[_._v("使用Nodejs配合http模块搭建路由服务；")]),_._v(" "),t("li",[_._v("解析、使用和存储Cookie;")]),_._v(" "),t("li",[_._v("Session使用和存储，包括如何高效管理Session；")]),_._v(" "),t("li",[_._v("通过网络缓存避免带宽浪费；")]),_._v(" "),t("li",[_._v("数据上传需要注意点：大文件使用流式解析、限制上传内容的大小、避免CSRF攻击加强校验；")]),_._v(" "),t("li",[_._v("中间件的理念和实现；")])]),_._v(" "),t("h2",{attrs:{id:"_9-玩转进程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-玩转进程"}},[_._v("#")]),_._v(" 9.玩转进程")]),_._v(" "),t("ol",[t("li",[_._v("服务模型：同步——>复制进程——>多线程——>事件驱动;")]),_._v(" "),t("li",[t("code",[_._v("child_process")]),_._v("模块搭建多进程;")])]),_._v(" "),t("p",[_._v("感谢 朴灵 写出这样的好书，并且分享给开发者。")])])}),[],!1,null,null,null);v.default=s.exports}}]);